#include <stdlib.h>
#include <stdio.h>

typedef struct logical_address logical_address;
typedef struct page_table page_table;
typedef struct physical_address physical_address;

/*
overview:  read each virtual address as an unsigned integer
and compute the p and d

Every address generated by the CPU is divided into two parts:
a page number (p) and a page offset (d)

notes:
logical_address size == 2**m
page size == 2**n (lower bits)

high-order bits of a logical address == the page number == (p) == m âˆ’ n
low-order bits designate == the page offset == n
*/

// overview: the main data structure which will be used.
struct logical_address{
  uint16_t page_number;
  uint16_t offset;
};

// The page number is used as an index into a page table
// The page table contains the base address of each page in physical memory. (f)
struct page_table{
  uint16_t page_number;
  uint16_t base_address;
};

struct physical_address{
  uint16_t base_address;
  uint16_t offset;
};

// overview: memory allocation routine.
logical_address *new_logical_address(){
  logical_address *address = (logical_address *)malloc(sizeof(logical_address));
  address->page_number = 0;
  address->offset = 0;
  return address;
}

// overview: the API of the paging module routines.
uint16_t compute_page_number(uint16_t m, uint16_t n, uint16_t v);
uint16_t compute_page_offset(uint16_t m, uint16_t n, uint16_t v);
void parse_logical_addresses(FILE *fp, int S, uint16_t l[]);
void perform_paging(logical_address **logical_address_array, uint16_t *v, int S);
int SIZE(FILE *fp);
